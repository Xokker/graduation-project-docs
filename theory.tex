\chapter{Теоретические основы}
\label{chapter:theory}

%TODO: указать какие задачи еще существуют
Хотя существует множество задач в сфере выявления предпочтений, в данной работе мы рассматриваем проблему ранжирования. Данная глава посвящена теоретическим основам задачи упорядочивания. Тем не менее, от читателя ожидается знание основ теории множеств и анализа формальных понятий (FCA, Formal Concept Analysis). Большая часть материала данной главы основана на \enquote{Введении} из сборника \textit{Preference Learning} Фюрнкранца и Хюллермайера\cite{plbook:Introduction:2010}.


\section{Теоретические основы задач ранжирования}

	Алгоритмы ранжирования могут отличаться друг от друга по ряду признаков. Так, часть алгоритмов работают с линейно упорядоченными множествами (полным порядком), в то время как другие работают с частичным порядком. Говорят, что отношение предпочтения является полным порядком, если про любые две альтернативы соединены отношением предпочтения. Это значит, что из каждой пары объектов\footnote{В данной работе слово \enquote{объект} используется как термин анализа формальных понятий} можно однозначно выбрать более предпочитаемый вариант (или, по крайней мере, выбрать вариант не хуже). С другой стороны, в случае частичного порядка могут существовать пары объектов, которые не связаны между собой отношением предпочтения. В таком случае мы имеем дело с частичном порядком. 
	
	Так же алгоритмы могут быть разделены по признаку возможности работы с нестрогими отношениями. Так, строгое отношение между объектами $a$ и $b$ может быть интерпретировано как \enquote{$a$ лучше $b$}, в то время как нестрогие отношения означают утверждения вида \enquote{$a$ не хуже $b$}.\cite[p.~384]{Barten:1982} Алгоритм выявления предпочтений \enquote{при прочих равных} может работать только с частичным порядком и нестрогим отношением предпочтения.

\subsection{Типы задач ранжирования}
	Фюрнкранц и Хюллермайер в \cite{plbook:Introduction:2010} выделяют три типа задач ранжирования: \emph{label ranking} (label ranking), \emph{ранжирование экземпляров} (instance ranking) и \emph{ранжирование объектов} (object ranking).
	
	\subsubsection{Label ranking}
		Данный тип ранжирование используется в ситуациях, когда надо найти порядок фиксированного набора элементов в зависимости от предоставленного контекста. Примером такого ранжирования может является упорядочение списка товаров в зависимости от личных данных клиента.
	
	%TODO: переформулировать
	\subsubsection{Ранжирование экземпляров}
		Данный тип используется в случаях, когда необходимо каждый из объектов отнести к фиксированному набору классов. Такое ранжирование обычно используется для оценки альтернатив, таких как оценка фильма в рекомендательной системе.
	
	\subsubsection{Объектное ранжирование}
		Алгоритмы для объектного ранжирования работают с 
		относительной %TODO: использовать другое слово
		информацией, в которой отсутствуют предопределенные категории. Для данной работы это наиболее важный тип ранжирования, так как рассматриваемый нами Алгоритм работает именно с попарными отношениями объектов (относительный порядок). Пример данного типа ранжирования приведен в главе \ref{???}.
		
		Так как в данной работе наиболее часто применение находит именно объектное ранжирование, на рис. \ref{fig:object_ranking} дано его формальное определение. Алгоритм выявления предпочтений \enquote{при прочих равных} решает более узкую задачу: на вход приходит множество уже проранжированных объектов $\Z \setminus \{e\}$ и объект $e$. Работа алгоритма заключается в упорядочении множества $\Z$.
		
		\begin{figure}[h]
			\hrule
			\begin{description}[nosep]
				\item[Дано:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item множество (возможно, бесконечное) объектов $\Z$ (обычно (но не обязательно) каждый объект представлен в виде вектора атрибутов)
					\item конечное множество попарных предпочтений $x_i \succ x_j, (x_i, x_j) \in \Z \times \Z$
				\end{itemize}
				\item[Найти:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item функцию ранжирования $f(\cdot)$, которая принимает на вход множество объектов и возвращает перестановку (ранжирует) этого множества
				\end{itemize}
			\end{description} 
			\hrule
			\caption{\it Определение объектного ранжирования (определение из \cite[Fig.~3]{plbook:Introduction:2010})}
			\label{fig:object_ranking}
		\end{figure}
	
	\subsection{Подходы к реализации}
		Фюрнкранц и Хюллермайер в \cite{plbook:Introduction:2010} представляют четыре подхода к реализации алгоритмов ранжирования. 
		Первый вариант – найти \emph{функцию полезности} и построить полный порядок основываясь на значениях, полученных с помощью этой функции. Такой подход применим ко всем трем типам задач ранжирования. 
		Второй подход заключается в \emph{выявлении зависимостей} в попарных отношениях предпочтения. Хотя часто подобный способ и создает более простую модель, в некоторых случаях может возникать нарушение транзитивности\cite[p.~10]{plbook:Introduction:2010}. 
		Третий подход называется \emph{Обучение предпочтениям, основанное на модели} и используется в случаях, когда известны некоторые ограничения об отношениях предпочтения. 
		Последний подход, который выделяют авторы, называется \emph{локальное агрегирование предпочтений}. Основная идея данного метода заключается в поиске ближайших \enquote{соседей} для данного объекта.
		
		Очевидно, что описанные подходы не являются взаимоисключающими. Алгоритм выявления предпочтений \enquote{при прочих равных} является примером смешения подходов. С одной стороны, Алгоритм имеет дело с бинарными отношениями и подходит к типу ''выявления зависимостей''. С другой стороны, он работает с отношениями \enquote{при прочих равных}, что накладывает определенные ограничения на результирующую модель. Следовательно, Алгоритм так же может быть отнесен к обучению, ''основанному на модели''.
	
	
\section{Алгоритм выявления предпочтений \enquote{при прочих равных}}

	Данный раздел основан на работе Объедкова \cite{Obiedkov:2013}, в которой представлен Алгоритм. Данный раздел состоит из двух секций: в первом представлен пример входных данных и описан ожидаемый результат работы Алгоритма, во втором представлено формальное определение Алгоритма.
	
	\subsection{Пример}
		На рис. \ref{fig:pcxt} представлен пример контекста предпочтений. Объекты $c_1, \dots, c_5$ представляют машины, у каждой из которых есть свой набор признаков. Например, $c_2$ является белым внедорожником с темным интерьером. Диаграмма на правой стороне показывает отношение предпочтений какого-то пользователя: $c_1$ не хуже, чем $c_2$ и $c_3$; $c_5$ не хуже, чем $c_1$; $c_2$ и $c_3$ несравнимы; и так далее. 
		\begin{figure}
			\begin{center} 
				\cars \prefs
				\caption{\it Пример контекста предпочтений \cite[Рис.~1.1]{Obiedkov:2013}}
				\label{fig:pcxt}	
			\end{center} 
		\end{figure} 
		
		Задача алгоритма предсказать отношения предпочтения при добавлении нового объекта в контекст. В рассматриваемом примере в контекст может быть добавлен красный миниван с ярким интерьером, и Алгоритм должен выявить отношения предпочтения для добавленной машины, попарно сравнив её с $c_1, \dots, c_5$. 
	
	\subsection{Описание алгоритма}
	%TODO: дописать
		Алгоритм \ref{algo:prediction} является реализацией алгоритма выявления предпочтений \enquote{при прочих равных}, написанной на псевдокоде. На шестой строке алгоритм вызывает подпрограмму, задача который убедиться, что никаие пары контекста не противоречат данному отношению.
		
		\begin{algorithm}
			\caption{\algname{Predict Preference}$(A, B, \PP)$ \cite[Alg.~1]{Obiedkov:2013}}
			\label{algo:prediction}
			\begin{algorithmic}[1]
				\REQUIRE Object intents $A, B \subseteq M$ and a preference context $\PP = (G, M, I, \leq)$.
				\ENSURE \TRUE, if $\PP$ supports $\DEF$ for some $D \subseteq A, E \subseteq B,$ and $F \subseteq M$ such that $F \cap A = F \cap B$; \FALSE, otherwise.
				\item[]
				\FORALL{$g \in G$}
				\STATE $D := A \cap g'$
				\FORALL{$h \in G \setminus \{g\}$ such that $g \leq h$}
				\STATE $E := B \cap h'$
				\STATE $F := (M \setminus (A \vartriangle B)) \cap (M \setminus (g' \vartriangle h'))$
				\IF{$\PP \models \DEF$}
				\RETURN \TRUE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \FALSE
			\end{algorithmic}
		\end{algorithm}
		\begin{algorithm}
			\caption{\algname{Check Preference}$(\DEF, \PP)$ \cite[Alg.~2]{Obiedkov:2013}}
			\label{algo:check}
			\begin{algorithmic}
				\REQUIRE A ceteris paribus preference $\DEF$ over $M$ and a preference context $\PP = (G, M, I, \leq)$.%; assume that attribute extents, $m'$ for $m \in M$, are precomputed.
				\ENSURE \TRUE, if $\PP \models \DEF$; \FALSE, otherwise.
				\STATE
				\STATE $X := \bigcap_{m \in D}m'$
				\STATE $Y := \bigcap_{m \in E}m'$
				\FORALL{$g \in X$}
				\FORALL{$h \in Y$}
				\IF {$g \not\leq h$ and $g' \cap {F} = h' \cap {F}$}
				\RETURN \FALSE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \TRUE
			\end{algorithmic}
		\end{algorithm}
		