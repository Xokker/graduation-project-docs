\chapter{Теоретические основы}
\label{chapter:theory}

%TODO: указать какие задачи еще существуют
Хотя существует множество задач в сфере выявления предпочтений, в данной работе мы рассматриваем проблему ранжирования. Данная глава посвящена теоретическим основам задачи упорядочивания. Тем не менее, от читателя ожидается знание основ теории множеств. Большая часть материала данной главы основана на \enquote{Введении} из сборника \textit{Preference Learning} Фюрнкранца и Хюллермайера\cite{plbook:Introduction:2010}.


\section{Теоретические основы задач ранжирования}

	Алгоритмы ранжирования могут отличаться друг от друга по ряду признаков. Так, часть алгоритмов работают с линейно упорядоченными множествами (полным порядком), в то время как другие работают с частичным порядком. Говорят, что отношение предпочтения является полным порядком, если про любые две альтернативы соединены отношением предпочтения. Это значит, что из каждой пары объектов\footnote{В данной работе слово \enquote{объект} используется как термин анализа формальных понятий} можно однозначно выбрать более предпочитаемый вариант (или, по крайней мере, выбрать вариант не хуже). С другой стороны, в случае частичного порядка могут существовать пары объектов, которые не связаны между собой отношением предпочтения. В таком случае мы имеем дело с частичном порядком. 
	
	Так же алгоритмы могут быть разделены по признаку возможности работы с нестрогими отношениями. Так, строгое отношение между объектами $a$ и $b$ может быть интерпретировано как \enquote{$a$ лучше $b$}, в то время как нестрогие отношения означают утверждения вида \enquote{$a$ не хуже $b$}.\cite[p.~384]{Barten:1982} Алгоритм выявления предпочтений \enquote{при прочих равных} может работать только с частичным порядком и нестрогим отношением предпочтения.

\subsection{Типы задач ранжирования}
	Фюрнкранц и Хюллермайер в \cite{plbook:Introduction:2010} выделяют три типа задач ранжирования: ''ранжирование меток" (\emph{label ranking}), ''ранжирование экземпляров'' (\emph{instance ranking}) и ''ранжирование объектов'' (\emph{object ranking}).
	
	\subsubsection{Ранжирование меток}
		Данный тип ранжирования используется в ситуациях, когда надо найти порядок фиксированного набора элементов в зависимости от предоставленного контекста. Примером такого ранжирования может является упорядочение списка товаров в зависимости от личных данных клиента.
	
	%TODO: переформулировать
	\subsubsection{Ранжирование экземпляров}
		Данный тип используется в случаях, когда необходимо каждый из объектов отнести к одному из классов из фиксированного набора. Такое ранжирование обычно используется для оценки альтернатив, таких как оценка фильма в рекомендательной системе.
	
	\subsubsection{Объектное ранжирование}
		Алгоритмы для объектного ранжирования работают с 
		относительной %TODO: использовать другое слово
		информацией, в которой отсутствуют предопределенные категории. Для данной работы это наиболее важный тип ранжирования, так как рассматриваемый нами Алгоритм работает именно с попарными отношениями объектов (относительный порядок). Пример данного типа ранжирования приведен в главе \ref{???}.
		
		Так как в данной работе наиболее часто применение находит именно объектное ранжирование, на рис. \ref{fig:object_ranking} дано его формальное определение. Алгоритм выявления предпочтений \enquote{при прочих равных} решает более узкую задачу: на вход приходит множество уже проранжированных объектов $\Z \setminus \{e\}$ и объект $e$. Работа алгоритма заключается в упорядочении множества $\Z$.
		
		\begin{figure}[h]
			\hrule
			\begin{description}[nosep]
				\item[Дано:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item множество (возможно, бесконечное) объектов $\Z$ (обычно (но не обязательно) каждый объект представлен в виде вектора атрибутов)
					\item конечное множество попарных предпочтений $x_i \succ x_j, (x_i, x_j) \in \Z \times \Z$
				\end{itemize}
				\item[Найти:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item функцию ранжирования $f(\cdot)$, которая принимает на вход множество объектов и возвращает перестановку (ранжирует) этого множества
				\end{itemize}
			\end{description} 
			\hrule
			\caption{\it Определение объектного ранжирования (определение из \cite[Рис.~3]{plbook:Introduction:2010})}
			\label{fig:object_ranking}
		\end{figure}
	
	\subsection{Подходы к реализации}
		В \cite{plbook:Introduction:2010} представлено четыре подхода к реализации алгоритмов ранжирования. 
		Первый вариант – найти \emph{функцию полезности} и построить полный порядок основываясь на значениях, полученных с помощью этой функции. Такой подход применим ко всем трем типам задач ранжирования. 
		Второй подход заключается в \emph{выявлении зависимостей} в попарных отношениях предпочтения. Хотя часто подобный способ и создает более простую модель, в некоторых случаях может возникать нарушение транзитивности\cite[стр.~10]{plbook:Introduction:2010}. 
		Третий подход называется \emph{обучение предпочтениям, основанное на модели} и используется в случаях, когда известны некоторые ограничения об отношениях предпочтения. 
		Последний подход, который выделяют авторы, называется \emph{локальное агрегирование предпочтений}. Основная идея данного метода заключается в поиске ближайших \enquote{соседей} для данного объекта.
		
		Очевидно, что описанные подходы не являются взаимоисключающими. Алгоритм выявления предпочтений \enquote{при прочих равных} является примером смешения подходов. С одной стороны, Алгоритм имеет дело с бинарными отношениями и подходит к типу ''выявления зависимостей''. С другой стороны, он работает с отношениями \enquote{при прочих равных}, что накладывает определенные ограничения на результирующую модель. Следовательно, Алгоритм так же может быть отнесен к обучению, ''основанному на модели''.
	
	
\section{Алгоритм выявления предпочтений \enquote{при прочих равных}}

	Данный раздел основан на работе Объедкова \cite{Obiedkov:2013}, в которой представлен Алгоритм. Данный раздел состоит из двух секций: в первом представлен пример входных данных и описан ожидаемый результат работы Алгоритма, во втором представлено формальное определение Алгоритма.
	
	\subsection{Пример}
		На рис. \ref{fig:pcxt} представлен пример контекста предпочтений. Объекты $c_1, \dots, c_5$ представляют машины, у каждой из которых есть свой набор признаков. Например, $c_2$ является белым внедорожником с темным интерьером. Диаграмма на правой стороне показывает отношение предпочтений какого-то пользователя: $c_1$ не хуже, чем $c_2$ и $c_3$; $c_5$ не хуже, чем $c_1$; $c_2$ и $c_3$ несравнимы; и так далее. 
		\begin{figure}
			\begin{center} 
				\cars \prefs
				\caption{\it Пример контекста предпочтений \cite[Рис.~1.1]{Obiedkov:2013}}
				\label{fig:pcxt}	
			\end{center} 
		\end{figure} 
		
		Задача алгоритма предсказать отношения предпочтения при добавлении нового объекта в контекст. В рассматриваемом примере в контекст может быть добавлен красный миниван с ярким интерьером, и Алгоритм должен выявить отношения предпочтения для добавленной машины, попарно сравнив её с $c_1, \dots, c_5$. 
	
	\subsection{Определения}
		Представленный в данной работе алгоритм оперирует сущностями анализа формальных понятий\cite{Ganter:1999}, а так же понятиями, определенными в \cite{Obiedkov:2012:preferences,Obiedkov:2012:modeling}. В данном разделе представлены эти определения.
		
		
		\begin{definition}
			\emph{(Формальный) контекст} – это тройка $\context = (G, M, I)$, где $G$ называется множеством \emph{объектов}, $M$ называется множеством \emph{признаков}, и бинарное отношение ${I \subseteq G \times M}$ указывает на принадлежность признаков к каждому из объектов.
		\end{definition}
		
		Формаьлный контекст может быть визуализирован с помощью таблицы, такой как Рис. \ref{fig:pcxt}.
		
		Для множеств $A \subseteq G$ и $B \subseteq M$ следующим образом определены \emph{операторы Галуа} (derivation operators) $(\cdot)'$:
		\begin{center}
			$A'=\{m \in M \mid \forall g \in A (g I m)\}$
			
			$B'=\{g \in G \mid \forall m \in B (g I m)\}$
		\end{center}
		$A'$ -– это набор признаком, которые есть у всех объектов множества $A$, а $B'$  –- набор объектов, каждый из которых содержит все признаки множества $B$. Пусть $g \in G$ и $m \in M$, тогда множества $\{g\}'$ и $\{m\}'$ называются \emph{содержание объекта} (object intent) и \emph{объем признака} (attribute extent), соответственно. Иногда их обозначают как $g'$ и $m'$.
		
		\begin{definition}
			\emph{Контекст предпочтений} $\PP = (G, M, I, \leq)$ это формальный контекст $(G, M, I)$ с рефлексивным и транзитивным отношением предпочтения $\leq$, определенным над $G$ (то есть, $\leq$ – предпорядок). Мы пишем $g < h$, если $g \leq h$ и $h \not\leq g$.
		\end{definition}
		
		Пример такого контекста представлен на Рис. \ref{fig:pcxt}.
		
		\begin{definition}
			Множество признаков $B \subseteq M$ \emph{предпочитается \enquote{при прочих равных}} множеству признаков $A \subseteq M$ по отношению ко множеству признаков $C \subseteq M$ в контексте предпочтений $\PP = (G, M, I, \leq)$ если 
			\[\forall g \in A' \forall h \in B'(\{g\}' \cap C = \{h\}' \cap C \to g \leq h).\]
			В таком случае мы говорим что предпочтение \emph{при прочих равных} $A \cp{C} B$ является \emph{валидным} или \emph{имеет место} в $\PP$ и обозначаем это как $\PP \models \ABC$.
		\end{definition}
	
	\subsection{Описание алгоритма}
	%TODO: дописать
		Алгоритм \ref{algo:prediction} является реализацией алгоритма выявления предпочтений \enquote{при прочих равных}, написанной на псевдокоде. На шестой строке алгоритм вызывает подпрограмму, задача который убедиться, что никакие пары контекста не противоречат данному отношению.
		
		\begin{algorithm}
			\caption{\algname{Предсказание предпочтения}$(A, B, \PP)$ \cite[Алг.~1]{Obiedkov:2013}}
			\label{algo:prediction}
			\begin{algorithmic}[1]
				\REQUIRE Object intents $A, B \subseteq M$ and a preference context $\PP = (G, M, I, \leq)$.
				\ENSURE \TRUE, if $\PP$ supports $\DEF$ for some $D \subseteq A, E \subseteq B,$ and $F \subseteq M$ such that $F \cap A = F \cap B$; \FALSE, otherwise.
				\item[]
				\FORALL{$g \in G$}
				\STATE $D := A \cap g'$
				\FORALL{$h \in G \setminus \{g\}$ such that $g \leq h$}
				\STATE $E := B \cap h'$
				\STATE $F := (M \setminus (A \vartriangle B)) \cap (M \setminus (g' \vartriangle h'))$
				\IF{$\PP \models \DEF$}
				\RETURN \TRUE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \FALSE
			\end{algorithmic}
		\end{algorithm}
		\begin{algorithm}
			\caption{\algname{Check Preference}$(\DEF, \PP)$ \cite[Alg.~2]{Obiedkov:2013}}
			\label{algo:check}
			\begin{algorithmic}
				\REQUIRE A ceteris paribus preference $\DEF$ over $M$ and a preference context $\PP = (G, M, I, \leq)$.%; assume that attribute extents, $m'$ for $m \in M$, are precomputed.
				\ENSURE \TRUE, if $\PP \models \DEF$; \FALSE, otherwise.
				\STATE
				\STATE $X := \bigcap_{m \in D}m'$
				\STATE $Y := \bigcap_{m \in E}m'$
				\FORALL{$g \in X$}
				\FORALL{$h \in Y$}
				\IF {$g \not\leq h$ and $g' \cap {F} = h' \cap {F}$}
				\RETURN \FALSE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \TRUE
			\end{algorithmic}
		\end{algorithm}
		