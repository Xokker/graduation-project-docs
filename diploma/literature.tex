\chapter{Обзор существующих решений}
\label{chapter:literature}

На тему задач ранжирования написано множество литературы. Помимо отдельных статьей опубликовано несколько сборников, посвященных данной проблеме. Примером такого сборника является \textit{Preference Learning} \cite{plbook:2010} Фюрнкранца и Хюллермайера, в котором авторы собрали широкий спектр различных работ на тему обучения предпочтений. Лиу в \textit{Learning to Rank for Information Retrieval} \cite{Liu:2011} представил обширные исследования задач ранжирования. Однако, основное внимание Лиу уделяет задачам извлечение информации, в то время как данная работа посвящена упорядочиванию объектов.

Фюрнкранц и Хюллермайер в \cite{plbook:Introduction:2010} представляют подробную классификацию задач ранжирования и методов для их решения. Подробнее данная классификация описана в Главе \ref{chapter:theory}. В другой работе \cite{Furnkranz:2003} авторы описывают алгоритм ранжирования, который выводит функцию полезности на основе отношений предпочтения.

Было предложено несколько методов для создания модели предпочтений. Хэддави и др. в \cite{Haddawy:2003} описали метод выявления предпочтений, основанный на простой нейросети. Жадный алгоритм, находящий аппроксимацию задачи ранжирования представил Кохен в \cite{Cohen:1999}.

Целый ряд алгоритмов машинного обучения был адаптирован для задач ранжирования. Примером такой адаптации является исследование, проведенное Женгом и др. в \cite{Zheng:2007}, где был предложен метод сведения задачи ранжирования к задачи регрессии. В дополнение, Бургерс и др. в \cite{Burges:2005} описали подход к задачи ранжирования, основанный на алгоритме градиентного спуска.

Камишима в \cite{Kamishima:2003} описывает проведенное им исследование, которое доказывает несостоятельность применения семантического дифференциала \cite{Osgood:1957} к пользовательским предпочтениям. Данные, собранные автором, показывают, что оценка альтернатив с помощью числовой шкалы не совпадает с более интуитивным методом сбора предпочтений – ранжированием. Отметим, что ранжированный список предпочтений и попарные предпочтения, рассматриваемые в настоящей работе, могут быть тривиальным образом трансформированы друг в друга.

%TODO: указать какие задачи еще существуют
Хотя существует множество задач в сфере выявления предпочтений, в данной работе мы рассматриваем проблему ранжирования. Данная глава посвящена теоретическим основам задачи упорядочивания. Большая часть материала данной главы основана на \enquote{Введении} из сборника \textit{Preference Learning} Фюрнкранца и Хюллермайера\cite{plbook:Introduction:2010}.

Остальная часть данной главы организована следующим образом: в первом разделе описан теоретический базис задач ранжирования, во втором представлены уже существующие алгоритмы, которые участвуют в экспериментах в Главе~\ref{chapter:experiments}.

\section{Теоретические основы задач ранжирования}

	Алгоритмы ранжирования могут отличаться друг от друга по ряду признаков. Так, часть алгоритмов работают с линейно упорядоченными множествами (полным порядком), в то время как другие работают с частичным порядком. Говорят, что отношение предпочтения является полным порядком, если любые две альтернативы связаны отношением предпочтения. Это значит, что из каждой пары объектов\footnote{В данной работе слово \enquote{объект} используется как термин анализа формальных понятий. Подробнее см. раздел \ref{subsection:definitions}} можно однозначно выбрать более предпочитаемый вариант (или, по крайней мере, выбрать вариант не хуже). С другой стороны, частичный порядок допускает существование пар объектов, которые не связаны между собой отношением предпочтения. 
	\begin{definition}
		\label{def:total_order}
		Отношение порядка $\leq$, для которого выполняется условие
		$\forall x,y\in X \quad  x\leq y \vee y \leq x$,
		называется \emph{полным порядком}.
	\end{definition}
	
	Предпочтения могут находиться в различных отношениях: предпорядка (preorder), нестрого порядка (nonstrict order) или строгого порядка (strict order). Так, строгое отношение между объектами $a$ и $b$ может быть интерпретировано как \enquote{$a$ лучше $b$}, в то время как нестрогие отношения означают утверждения вида \enquote{$a$ не хуже $b$}\cite[с.~384]{Barten:1982}. Предпорядок – это нестрогий порядок без свойства антисимметричности. Определения \ref{def:preorder}, \ref{def:nonstrict_order} и \ref{def:strict_order} представляют формальные описания данных понятий.
	
	\begin{definition}
		\label{def:preorder}
		Отношение $\leq$ называется \emph{предпорядком} (или квазипорядком) на множестве $S$, если оно удовлетворяет следующим условиям\cite{harel:2000}:
		\begin{itemize}[itemsep=-1.5mm]
			\item Рефлексивность: $a \leq a \quad \forall a \in S$
			\item Транзитивность: $a \leq b\: \wedge\: b \leq c \implies a \leq c$ 
		\end{itemize}
	\end{definition}	
	\begin{definition}
		\label{def:nonstrict_order}
		Множество $S$ находится в \emph{нестрогом порядке}, если это множество – предпорядок, и на нем выполняется свойство антисимметричности\cite{Skiena:1991}: $a \leq b\; \wedge\; b \leq a \implies a = b$.
	\end{definition}
	\begin{definition}
		\label{def:strict_order}
		Множество $S$ находится в \emph{строгом порядке}, если на этом множестве выполняются следующие свойства:
		\begin{itemize}[itemsep=-1.5mm]
			\item Антирефлексивность: $ a \nless a \quad \forall a \in S$
			\item Асимметричность: $a < b \implies b \nless a \quad \forall \, (a, b) \in S$
			\item Транзитивность: $a < b\: \wedge\: b < c \implies a < c$
		\end{itemize}
		Если в нестрогом порядке условие рефлексивности заменить на антирефлексивность, получится строгий порядок.
	\end{definition}
	
	Алгоритм выявления предпочтений \enquote{при прочих равных} работает с предпорядками.
	
	\subsection{Типы задач ранжирования}
	Фюрнкранц и Хюллермайер в \cite{plbook:Introduction:2010} выделяют три типа задач ранжирования: ``ранжирование меток" (\emph{label ranking}), ``ранжирование экземпляров'' (\emph{instance ranking}) и ``ранжирование объектов'' (\emph{object ranking}).
	
	\subsubsection{Ранжирование меток}
	Данный тип ранжирования используется в ситуациях, когда надо найти порядок фиксированного набора элементов в зависимости от предоставленного контекста. Примером такого ранжирования может является упорядочение списка товаров в зависимости от личных данных клиента.
	
	\begin{figure}[h!]
		\hrule
		\begin{description}[nosep]
			\item[Дано:] \null\leavevmode
			\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
				\item обучающий набор данных $\{\bm{x}_\ell \, | \, \ell = 1,2,\dotsc,n\} \subseteq \mathcal{X} $ (обычно, но не обязательно, каждый экземпляр представлен в виде вектора атрибутов)
				\item множество меток $\mathcal{Y} = \{y_i\,|\,i = 1,2,\dotsc,k\}$
				\item для каждого экземпляра тренировочного набора данных $\bm{x}_\ell$: множество попарных предпочтений в виде $y_i \succ_{\bm{x}_\ell} y_j $ (данная нотация читается как ``для данного $\bm{x}_\ell$  метка $y_i$ предпочитается метке $y_j$'')
			\end{itemize}
			\item[Найти:] \null\leavevmode
			\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
				\item функцию ранжирования, которая отображает каждый $\bm{x} \in \mathcal{X}$ в перестановку $\succ_{\bm{x}_\ell}$ множества $\mathcal{Y}$
			\end{itemize}
		\end{description} 
		\hrule
		\label{fig:label_ranking}
	\end{figure}
	
	%TODO: переформулировать
	\subsubsection{Ранжирование экземпляров}
	Данный тип используется в случаях, когда необходимо каждый из объектов отнести к одному из классов из фиксированного набора. Такое ранжирование обычно используется для оценки альтернатив, таких как оценка фильма в рекомендательной системе.
	
	\begin{figure}[h!]
		\hrule
		\begin{description}[nosep]
			\item[Дано:] \null\leavevmode
			\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
				\item набор тренировочных данных $\{\bm{x}_\ell \, | \, \ell = 1,2,\dots,n\} \subseteq \mathcal{X} $ (обычно, но не обязательно, каждый экземпляр представлен в виде вектора атрибутов)
				\item множество меток $\mathcal{Y} = \{y_i\,|\,i = 1,2,\dotsc,k\}$ и их порядок $y_1 < y_2 < \dotsb < y_k$ 
				\item соответствие каждого экземпляра тренировочного набора данных $\bm{x}_\ell$ метке $y_\ell$
			\end{itemize}
			\item[Найти:] \null\leavevmode
			\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
				\item функцию, которая позволяет ранжировать множество экземпляров $\{\bm{x}_j\}^t_{j=1}$ согласно (неизвестному) уровню предпочтений
			\end{itemize}
		\end{description} 
		\hrule
		\label{fig:instance_ranking}
	\end{figure}
	
	\subsubsection{Объектное ранжирование}
	Алгоритмы для объектного ранжирования работают с 
	относительной %TODO: использовать другое слово
	информацией, в которой отсутствуют предопределенные категории. Для данной работы это наиболее важный тип ранжирования, так как  Алгоритм работает именно с попарными отношениями объектов (относительный порядок). Пример данного типа ранжирования приведен в разделе \ref{subsection:example}.
	
	Ниже представлено формальное определение объектного ранжирования. Алгоритм выявления предпочтений \enquote{при прочих равных} решает более узкую задачу: на вход приходит множество уже проранжированных объектов $\Z \setminus \{e\}$ и объект $e$. Работа алгоритма заключается в упорядочении множества $\Z$.
	
	\begin{figure}[h!]
		\hrule
		\begin{description}[nosep]
			\item[Дано:] \null\leavevmode
			\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
				\item множество (возможно, бесконечное) объектов $\Z$ (обычно, но не обязательно, каждый объект представлен в виде вектора признаков)
				\item конечное множество попарных предпочтений $\bm{x}_i \succ \bm{x}_j, \: (\bm{x}_i, \bm{x}_j) \in \Z \times \Z$
			\end{itemize}
			\item[Найти:] \null\leavevmode
			\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
				\item функцию ранжирования $f(\cdot)$, которая принимает на вход множество объектов и возвращает перестановку (ранжирует) этого множества
			\end{itemize}
		\end{description} 
		\hrule
		\label{fig:object_ranking}
	\end{figure}
	
	\subsection{Подходы к реализации}
	В \cite{plbook:Introduction:2010} представлено четыре подхода к реализации алгоритмов ранжирования. 
	Первый вариант – выявить \emph{функцию полезности} (learning utility function) и построить полный порядок, основываясь на значениях, полученных с помощью этой функции. Такой подход применим ко всем трем типам задач ранжирования. 
	Второй подход заключается в \emph{выявлении зависимостей} в попарных отношениях предпочтения (learning preference relations). Хотя часто подобный способ и создает более простую модель, в некоторых случаях может возникать нарушение транзитивности\cite[с.~10]{plbook:Introduction:2010}. 
	Третий подход называется \emph{обучение предпочтениям, основанное на модели} (model-based preference learning). Он используется в случаях, когда известны некоторые ограничения об отношениях предпочтения. 
	Последний подход, который выделяют авторы, называется \emph{локальное агрегирование предпочтений} (local aggregation of preferences). Основная идея данного метода заключается в поиске ближайших \enquote{соседей} для данного объекта.
	
	Очевидно, что описанные подходы не являются взаимоисключающими. Алгоритм выявления предпочтений \enquote{при прочих равных} является примером смешения подходов: с одной стороны, Алгоритм имеет дело с бинарными отношениями и подходит к типу ``выявления зависимостей''; с другой стороны, он работает с отношениями \enquote{при прочих равных}, что накладывает определенные ограничения на результирующую модель. Следовательно, Алгоритм так же может быть отнесен к обучению, ``основанному на модели''.

\section{Рассматриваемые алгоритмы}

	Как описано в Введении, первоочередная задача данной работы – сравнение Алгоритма \ref{algo:prediction} с другими методами машинного обучения. В сравнении участвуют методы классифицирующих деревьев, а так же Байесовские методы. В разделах \ref{subsec:c4.5} -- \ref{subsec:bayes_net} подробно описаны эти алгоритмы.
	
	\subsection{C4.5}
	\label{subsec:c4.5}
	<...>
	
	\subsection{Наивный Байесовский классификатор}
	\label{subsec:naive_bayes}
	<...>
	
	\subsection{Байесовская сеть}
	\label{subsec:bayes_net}
	<...>