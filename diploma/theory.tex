\chapter{Теоретические основы Алгоритма}
\label{chapter:theory}

В данной главе представлено формальное описание Алгоритма, а так же описана его модификация, которая расширяет его возможности.
	
\section[Алгоритм выявления предпочтений \enquote{при прочих равных}]{\setstretch{0.8} Алгоритм выявления предпочтений \\ \enquote{при прочих равных}}

	Данный раздел основан на работе С.А. Объедкова \cite{Obiedkov:2013}, в которой представлен Алгоритм. Раздел состоит из двух пунктов: в первом представлен пример входных данных и описан ожидаемый результат работы Алгоритма, во втором представлено формальное определение Алгоритма.
	
	\subsection{Пример}
	\label{subsection:example}
		На рисунке представлен пример контекста предпочтений. Объекты $c_1, \dotsc, c_5$ представляют машины, у каждой из которых есть свой набор признаков. Например, $c_2$ является белым внедорожником с темным интерьером. Диаграмма на правой стороне показывает отношение предпочтений какого-то пользователя: $c_1$ не хуже, чем $c_2$ и $c_3$; $c_5$ не хуже, чем $c_1$; $c_2$ и $c_3$ несравнимы; и так далее. 
		\begin{figure}
			\begin{center} 
				\cars \prefs
				\caption*{\it Пример контекста предпочтений \cite[Рис.~1.1]{Obiedkov:2013}}
				\label{fig:pcxt}	
			\end{center} 
		\end{figure} 
		
		Задача Алгоритма предсказать отношения предпочтения при добавлении нового объекта в контекст. В рассматриваемом примере в контекст может быть добавлен красный миниван с ярким интерьером, и Алгоритм должен выявить отношения предпочтения для добавленной машины, попарно сравнив её с $c_1, \dotsc, c_5$. 
	
	\subsection{Определения}
	\label{subsection:definitions}
		Представленный в данной работе алгоритм оперирует сущностями анализа формальных понятий (formal concept analysis)\cite{Ganter:1999}, а так же понятиями, определенными в \cite{Obiedkov:2012:preferences,Obiedkov:2012:modeling}. В данном разделе представлены эти определения.
		
		
		\begin{definition}
		\label{def:context}
			\emph{(Формальный) контекст} – это тройка $\context = (G, M, I)$, где $G$ называется множеством \emph{объектов}, $M$ называется множеством \emph{признаков}, и бинарное отношение ${I \subseteq G \times M}$ указывает на принадлежность признаков к каждому из объектов.
		\end{definition}
		
		Формаьлный контекст может быть визуализирован с помощью таблицы, такой как изображена на рисунке.
		
		Для множеств $O \subseteq G$ и $C \subseteq M$ следующим образом определены \emph{операторы Галуа} (derivation operators) $(\cdot)'$:
		\begin{subequations}
			\begin{gather}
			\label{eq:object_intent}
			O'=\{m \in M \mid \forall g \in O (g I m)\}  \\ 
			% 
			\label{eq:attribute_extent}
			C'=\{g \in G \mid \forall m \in C (g I m)\}
			\end{gather}
		\end{subequations}
		где $O'$ – это набор признаков, которые есть у всех объектов множества $O$, а $C'$  –- набор объектов, каждый из которых содержит все признаки множества $C$. Пусть $g \in G$ и $m \in M$, тогда множества $\{g\}'$ и $\{m\}'$ называются \emph{содержанием объекта} (object intent) и \emph{объемом признака} (attribute extent), соответственно. Иногда их обозначают как $g'$ и $m'$.
		
		\begin{definition}
		\label{def:preference_context}
			\emph{Контекст предпочтений} $\PP = (G, M, I, \leq)$ – это формальный контекст $(G, M, I)$ с рефлексивным и транзитивным отношением предпочтения $\leq$, определенным над $G$ (то есть, $\leq$ – предпорядок). Мы пишем $g < h$, если $g \leq h$ и $h \not\leq g$.
		\end{definition}
		\noindent Пример такого контекста представлен на рисунке.
		
		\begin{definition}
		\label{def:ceteris_paribus}
			Множество признаков $D \subseteq M$ \emph{предпочитается \enquote{при прочих равных}} множеству признаков $E \subseteq M$ по отношению ко множеству признаков $F \subseteq M$ в контексте предпочтений $\PP = (G, M, I, \leq)$ если 
			\begin{equation}
			\forall g \in D' \quad \forall h \in E' \quad (\{g\}' \cap F = \{h\}' \cap F \, \implies \, g \leq h).
			\end{equation}
			В таком случае мы говорим, что предпочтение \emph{при прочих равных} $A \cp{C} B$ является \emph{валидным} или \emph{имеет место} в $\PP$ и обозначаем это как $\PP \models \ABC$.
		\end{definition}
	
	\subsection{Описание алгоритма}
	\label{subsec:cp_description}
		Задача Алгоритма~\ref{algo:prediction} – предугадать отношение между двумя объектами $a$ и $b$, которые выражены множествами признаков $A$ и $B$ ($a' = A$ и $b' = B$). Для этого алгоритм в контексте $\PP$ находит пару объектов $(g, h)$, которая на основе ряда признаков позволяет сделать вывод о том, что $a \leq b$. В случае, если такая пара не найдена, алгоритм должен вернуть значение ``ложь'', что означает $a \nleq b$. Чтобы найти объекты $g$ и $h$ алгоритм ищет тройку, состоящую из множеств $D$, $F$ и $E$, имеющую следующие признаки:
		\begin{itemize}
			\item Множество $D$ состоит из признаков, которые присущи и объекту $g$, и объекту $a$
			\item Множество $E$ состоит из признаков, которые присущи и объекту $h$, и объекту $b$
			\item Множество $F$ является пересечением двух множеств. Первое содержит признаки, по которым ``сходятся'' (то есть в множество попадут только признаки, которые есть и в $a'$, и в $b'$, или их нет ни там, ни там) объекты $a$ и $b$ $(M \setminus (A \vartriangle B))$. Аналогично, второе множество состоит из признаков, по которым совпадают объекты $g$ и $h$ $(M \setminus (g' \vartriangle h'))$. Таким образом, $F$ содержит признаки, по по которым должны совпадать сравниваемые объекты для того, чтобы данное предпочтение было преминимо.
		\end{itemize}
		После нахождения тройки $(D,F,E)$ алгоритм проверяет выполнение предпочтения $\DEF$ в контексте $\PP$. Если $\PP \models \DEF$ выполняется, то алгоритм делает вывод о том, что $a \leq b$.
	
		\begin{algorithm}
			\caption{\algname{Предсказание предпочтения}$(A, B, \PP)$ \cite[Алг.~1]{Obiedkov:2013}}
			\label{algo:prediction}
			\begin{algorithmic}[1]
				\REQUIRE Содержания объектов $A, B \subseteq M$ и контекст предпочтений $\PP = (G, M, I, \leq)$.
				\ENSURE \TRUE, если $\PP$ поддерживает $\DEF$ для некоторого $D \subseteq A, E \subseteq B,$ и $F \subseteq M$ таких, что $F \cap A = F \cap B$; \FALSE, иначе.
				\item[]
				\FORALL{$g \in G$}
				\STATE $D := A \cap g'$
				\FORALL{$h \in G \setminus \{g\}$ таких, что $g \leq h$}
				\STATE $E := B \cap h'$
				\STATE $F := (M \setminus (A \vartriangle B)) \cap (M \setminus (g' \vartriangle h'))$
				\IF{$\PP \models \DEF$}
				\RETURN \TRUE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \FALSE
			\end{algorithmic}
		\end{algorithm}
		
		Для проверки выполнения $\DEF$ в $\PP$ Алгоритм~\ref{algo:check} находит объекты, которые содержат все признаки из $D$ (результат во множестве $X$), и объекты, которые содержат все признаки из $E$ (результат во множестве $Y$). Если находится хоть одна пара $(g,h) \in (X, Y)$, которая опровергает $\DEF$ ($g'$ и $h'$ равны по признакам из $F$, но при этом $g \nleq h$), то возвращается ``ложь''. Таким образом, задача Алгоритма~\ref{algo:check} – убедиться, что в контексте $\PP$ нет пары объектов, которая бы опровергала $\DEF$. 
	
	
		\begin{algorithm}
			\caption{\algname{Проверить предпочтение}$(\DEF, \PP)$ \cite[Алг.~2]{Obiedkov:2013}}
			\label{algo:check}
			\begin{algorithmic}[1]
				\REQUIRE Предпочтение $\DEF$ над $M$ и контекст предпочтений $\PP = (G, M, I, \leq)$
				\ENSURE \TRUE, если $\PP \models \DEF$; \FALSE, иначе.
				\item[]
				\STATE $X := \bigcap_{m \in D}m'$
				\STATE $Y := \bigcap_{m \in E}m'$
				\FORALL{$g \in X$}
				\FORALL{$h \in Y$}
				\IF {$g \not\leq h$ and $g' \cap {F} = h' \cap {F}$}
				\RETURN \FALSE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \TRUE
			\end{algorithmic}
		\end{algorithm}
		


\section{Модификация Алгоритма}	
\label{sec:modification}	
		
	Алгоритм выявления предпочтений \enquote{при прочих равных} работает лишь с бинарными признаками. Однако, наборы данных, рассматриваемые в данной работе, содержат в том числе многозначные и числовые признаки. В этом разделе представлена модификация Алгоритма, которая умеет работать с небинарными признаками. В главе~\ref{chapter:experiments} представлены результаты экспериментов не только над базовой версией Алгоритма, но и над модифицированной.
	
	В основе модификации лежит идея изменения $F$ (см. опр.~\ref{def:ceteris_paribus}): вместо множества признаков используется множество предикатов. При этом меняется семантика Алгоритма. В статье \cite{Obiedkov:2013}, где он был представлен, использовались только бинарные признаки (например, экстерьер мог быть только красным или белым, см. рисунок). Таким образом, из появления в $F$ одного из признаков группы (например, группы признаков ``экстерьер'') следовало наличие или отсутствие второго признака. При использовании предикатов множество $F$ представляет набор утверждений вида ``левая и правая часть равны по признаку $c$'', где $c$ – некая категория признаков. Переход от множества признаков ко множеству предикатов позволяет строить более сложные утверждения (например, рассматривать неравенства), а так же работать с многозначными и числовыми признаками в дополнение к бинарным. Определение \ref{def:multivalued_context}\cite{Ganter:1997} является формальным описанием \emph{многозначного контекста}, который может содержать небинарные признаки.
	
	\begin{definition}
		\label{def:multivalued_context}
		\emph{Многозначный (формальный) контекст} – это кортеж $\context^* = (G, M^*, V, J)$, где $G$ называется множеством объектов, $M^*$ – множество признаков, $V$ – множество \emph{значений}, а J является тернарным отношением ${I \subseteq G \times M^* \times V}$, содержащим тройки $(g\:m\:v)$. $(g\:m\:v)$ интерпретируется как ``значение признака $m$ объекта $g$ равно $v$''. 
	\end{definition}
	
	Контекст предпочтений, основанный на $\context^*$ (\emph{многозначный контекст предпочтений}), будем обозначать $\PP^*$. Аналогично опр.~\ref{def:preference_context}, $\PP^* = (G, M^*, V, J, \leq)$.
	
	Обозначим $\mathbb{A} = \{A_1, A_2, \dots, A_n\}$ множество всех категориальных многозначных признаков, а $\mathbb{C} = \{C_1, C_2, \dots, C_m\}$ множество всех числовых признаков. Тогда $M^* = \mathbb{A} \cup \mathbb{C}$.
	
	Нами вводятся 3 типа предикатов, а так же множества, состоящие из представленных предикатов:
	\begin{subequations} %TODO: merge condition
		\begin{gather} 
		\label{eq:eq_predicate}
		p^=_m(v^*_i, v^*_j) := (v^*_i = v^*_j) \\ 
		% 
		\label{eq:lt_predicate}
		p^<_m(v_i, v_j) := (v_i < v_j) \\ 
		%
		\label{eq:gt_predicate}
		p^>_m(v_i, v_j) := (v_i > v_j)
		\end{gather}
	\end{subequations}
	где $v^*_i$ и $v^*_j$ в \eqref{eq:eq_predicate} – значения некого признака m, \\
	$v_i$ и $v_j$ в \eqref{eq:lt_predicate} и \eqref{eq:gt_predicate} – некоторые значения числового признака $m$. \\
	\begin{subequations} 
		\begin{gather}
		\label{eq:all_predicates_m}
		P_m = \{p^=_m, p^<_m, p^>_m\} \\
		%
		\label{eq:all_predicates}
		\mathbb{P} = \bigcup_{m \in M^*}P_m
		\end{gather}
	\end{subequations}
	где $P_m$ содержит все предикаты для признака $m$, \\
	$\mathbb{P}$ содержит все предикаты для всех признаков.\\
	В дальнейшем введенные предикаты используются для попарного выявления отношений между признаками двух объектов.\\
	Обозначим через $\mathtt{v}_m(g)$ функцию, которая показывает значение признака $m$ объекта $g$:
	\begin{equation}
	\mathtt{v}_m(g) = v\;|\;(g\:m\:v) \in J \quad \text{для данного $\context^*$}
	\end{equation} \\
	Для удобства определим предикаты для объектов:
	\begin{equation}
	\label{eq:obj_predicate}
	p^{\{<,=,>\}}_m(x, y) := p^{\{<,=,>\}}_m(\mathtt{v}_m(x), \mathtt{v}_m(y))
	\end{equation}
	где $x$ и $y$ – некоторые объекты. \\
	Например, существуют два объекта $x$ и $y$, которые представляют автомобили: седан с ручной трансмиссией и объемом двигателя 3.5L; и SUV с ручной трансмиссией и объемом двигателя 5.5L. Тогда для пары объектов $(x, y)$ будут выполняться предикаты $p^=_{\text{тран.}}(x, y)$ и  $p^<_{\text{двиг.}}(x, y)$, но не будут выполняться  $p^>_{\text{двиг.}}(x, y)$, $p^=_{\text{кузов}}(x, y)$.
	
	Алгоритмы \ref{algo:prediction_multi} и \ref{algo:check_multi} являются модификациями алгоритмов \ref{algo:prediction} и \ref{algo:check}, соответственно. В отличие от своих базовых версий, данные алгоритмы работают с многозначным контекстом предпочтений. А значит, меняется семантика множества $F$: в отличие от Алг.~\ref{algo:prediction}, в котором $F$ содержало признаки, по которым совпадают $A$ и $B$, а также $g$ и $h$, $F$ в Алг.~\ref{algo:prediction_multi} содержит предикаты, которые выполняются и для объектов $A'$ и $B'$ (объекты представлены признаками $A$ и $B$), и для $g$ и $h$.
	
	\begin{algorithm}
		\caption{\algname{Предсказание предпочтения}$(A, B, \PP^*)$ (Основан на Алг.~\ref{algo:prediction})}
		\label{algo:prediction_multi}
		\begin{algorithmic}[1]
			\REQUIRE Содержания объектов $A, B \subseteq M^* \times V$ и контекст предпочтений $\PP^* = (G, M^*, V, J, \leq)$.
			\ENSURE \TRUE, если $\PP^*$ поддерживает $\DEF$ для некоторого $D \subseteq A, E \subseteq B,$ и $F \subseteq \mathbb{P}$ таких, что $F \cap A = F \cap B$; \FALSE, иначе.
			\item[]
			\FORALL{$g \in G$}
			\STATE $D := A \cap g'$
			\FORALL{$h \in G \setminus \{g\}$ таких, что $g \leq h$}
			\STATE $E := B \cap h'$
			\STATE $F_{ab} := \{p\;|\;p \in \mathbb{P} \wedge p\,(A', B')\}$
			\STATE $F_{gh} := \{p\;|\;p \in \mathbb{P} \wedge p\,(g, h)\}$
			\STATE $F := F_{ab} \cap F_{gh}$
			\IF{$\PP \models \DEF$}
			\RETURN \TRUE
			\ENDIF
			\ENDFOR
			\ENDFOR
			\RETURN \FALSE
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}
		\caption{\algname{Проверить предпочтение}$(\DEF, \PP^*)$ (Основан на Алг.~\ref{algo:check})}
		\label{algo:check_multi}
		\begin{algorithmic}[1]
			\REQUIRE Предпочтение $\DEF$ над $M$ и контекст предпочтений $\PP^* = (G, M^*, V, J, \leq)$
			\ENSURE \TRUE, если $\PP^* \models \DEF$; \FALSE, иначе.
			\item[]
			\STATE $X := \bigcap_{m \in D}m'$
			\STATE $Y := \bigcap_{m \in E}m'$
			\FORALL{$g \in X$}
			\FORALL{$h \in Y$}
			\IF {$g \not\leq h$ \AND $p\,(g, h)\: \forall p \in F$}
			\RETURN \FALSE
			\ENDIF
			\ENDFOR
			\ENDFOR
			\RETURN \TRUE
		\end{algorithmic}
	\end{algorithm}