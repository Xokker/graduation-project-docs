\chapter{Теоретические основы}
\label{chapter:theory}

%TODO: указать какие задачи еще существуют
Хотя существует множество задач в сфере выявления предпочтений, в данной работе мы рассматриваем проблему ранжирования. Данная глава посвящена теоретическим основам задачи упорядочивания. Тем не менее, от читателя ожидается знание основ теории множеств. Большая часть материала данной главы основана на \enquote{Введении} из сборника \textit{Preference Learning} Фюрнкранца и Хюллермайера\cite{plbook:Introduction:2010}.


\section{Теоретические основы задач ранжирования}

	Алгоритмы ранжирования могут отличаться друг от друга по ряду признаков. Так, часть алгоритмов работают с линейно упорядоченными множествами (полным порядком), в то время как другие работают с частичным порядком. Говорят, что отношение предпочтения является полным порядком, если про любые две альтернативы связаны отношением предпочтения. Это значит, что из каждой пары объектов\footnote{В данной работе слово \enquote{объект} используется как термин анализа формальных понятий. Подробнее см. секцию \ref{subsection:definitions}} можно однозначно выбрать более предпочитаемый вариант (или, по крайней мере, выбрать вариант не хуже). С другой стороны, частичный порядок допускает существование пар объектов, которые не связаны между собой отношением предпочтения. 
	\begin{definition}
	\label{def:total_order}
		Отношение порядка $\leq$, для которого выполняется условие
		$\forall x,y\in X \quad  ( x\leq y) \vee (y \leq x)$,
		называется \emph{полным порядком}.
	\end{definition}
	
	Предпочтения могут находиться в различных отношениях: предпорядка (preorder), нестрого порядка (nonstrict order) или строгого порядка (strict order). Так, строгое отношение между объектами $a$ и $b$ может быть интерпретировано как \enquote{$a$ лучше $b$}, в то время как нестрогие отношения означают утверждения вида \enquote{$a$ не хуже $b$}\cite[p.~384]{Barten:1982}. Предпорядок – это нестрогий порядок без свойства антисимметричности. Определения \ref{def:preorder}, \ref{def:nonstrict_order} и \ref{def:strict_order} представляют формальные описания данных понятий.
	
	\begin{definition}
	\label{def:preorder}
		Отношение $\leq$ называется \emph{предпорядком} (или квазипорядком) на множестве $S$, если оно удовлетворяет следующим условиям\cite{harel:2000}:
		\begin{itemize}[itemsep=-1.5mm]
			\item Рефлексивность: $a \leq a \quad \forall a \in S$
			\item Транзитивность: $a \leq b\: \wedge\: b \leq c \implies a \leq c$ 
		\end{itemize}
	\end{definition}	
	\begin{definition}
	\label{def:nonstrict_order}
		Множество $S$ находится в \emph{нестрогом порядке}, если это множество – предпорядок, и на нем выполняется свойство антисимметричности\cite{Skiena:1991}: $a \leq b\; \wedge\; b \leq a \implies a = b$.
	\end{definition}
	\begin{definition}
	\label{def:strict_order}
		Множество $S$ находится в \emph{строгом порядке}, если на этом множестве выполняются следующие свойства\cite{???}:
		\begin{itemize}[itemsep=-1.5mm]
			\item Антирефлексивность: $ a \nless a \quad \forall a \in S$
			\item Асимметричность: $a < b \implies b \nless a \quad \forall \, (a, b) \in S$
			\item Транзитивность: $a < b\: \wedge\: b < c \implies a < c$
		\end{itemize}
		Если в нестрогом порядке условие рефлексивности заменить на антирефлексивность, получится строгий порядок.
	\end{definition}

	 Алгоритм выявления предпочтений \enquote{при прочих равных} работает с предпорядками.

\subsection{Типы задач ранжирования}
	Фюрнкранц и Хюллермайер в \cite{plbook:Introduction:2010} выделяют три типа задач ранжирования: ``ранжирование меток" (\emph{label ranking}), ``ранжирование экземпляров'' (\emph{instance ranking}) и ``ранжирование объектов'' (\emph{object ranking}).
	
	\subsubsection{Ранжирование меток}
		Данный тип ранжирования используется в ситуациях, когда надо найти порядок фиксированного набора элементов в зависимости от предоставленного контекста. Примером такого ранжирования может является упорядочение списка товаров в зависимости от личных данных клиента. (рис.~\ref{fig:label_ranking})
	
		\begin{figure}[h]
			\hrule
			\begin{description}[nosep]
				\item[Дано:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item набор тренировочных данных $\{\bm{x}_\ell \, | \, \ell = 1,2,\dotsc,n\} \subseteq \mathcal{X} $ (обычно, но не обязательно, каждый экземпляр представлен в виде вектора атрибутов)
					\item множество меток $\mathcal{Y} = \{y_i\,|\,i = 1,2,\dotsc,k\}$
					\item для каждого экземпляра тренировочного набора данных $\bm{x}_\ell$: множество попарных предпочтений в виде $y_i \succ_{\bm{x}_\ell} y_j $
				\end{itemize}
				\item[Найти:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item функцию ранжирования, которая отображает каждый $\bm{x} \in \mathcal{X}$ в перестановку $\succ_{\bm{x}_\ell}$ множества $\mathcal{Y}$
				\end{itemize}
			\end{description} 
			\hrule
			\caption{\it Определение ранжирования меток \cite[Рис.~1]{plbook:Introduction:2010}}
			\label{fig:label_ranking}
		\end{figure}
	
	%TODO: переформулировать
	\subsubsection{Ранжирование экземпляров}
		Данный тип используется в случаях, когда необходимо каждый из объектов отнести к одному из классов из фиксированного набора. Такое ранжирование обычно используется для оценки альтернатив, таких как оценка фильма в рекомендательной системе. (рис.~\ref{fig:instance_ranking})
		
		\begin{figure}[h]
			\hrule
			\begin{description}[nosep]
				\item[Дано:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item набор тренировочных данных $\{\bm{x}_\ell \, | \, \ell = 1,2,\dots,n\} \subseteq \mathcal{X} $ (обычно, но не обязательно, каждый экземпляр представлен в виде вектора атрибутов)
					\item множество меток $\mathcal{Y} = \{y_i\,|\,i = 1,2,\dotsc,k\}$ и их порядок $y_1 < y_2 < \dotsb < y_k$ 
					\item соответствие каждого экземпляра тренировочного набора данных $\bm{x}_\ell$ метке $y_\ell$
				\end{itemize}
				\item[Найти:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item функцию, которая позволяет ранжировать множество экземпляров $\{\bm{x}_j\}^t_{j=1}$ согласно (неизвестному) уровню предпочтений
				\end{itemize}
			\end{description} 
			\hrule
			\caption{\it Определение ранжирования экземпляров \cite[Рис.~2]{plbook:Introduction:2010}}
			\label{fig:instance_ranking}
		\end{figure}
	
	\subsubsection{Объектное ранжирование}
		Алгоритмы для объектного ранжирования работают с 
		относительной %TODO: использовать другое слово
		информацией, в которой отсутствуют предопределенные категории. Для данной работы это наиболее важный тип ранжирования, так как рассматриваемый нами Алгоритм работает именно с попарными отношениями объектов (относительный порядок). Пример данного типа ранжирования приведен в секции \ref{subsection:example}.
		
		На рисунке \ref{fig:object_ranking} дано формальное определение объектного ранжирования. Алгоритм выявления предпочтений \enquote{при прочих равных} решает более узкую задачу: на вход приходит множество уже проранжированных объектов $\Z \setminus \{e\}$ и объект $e$. Работа алгоритма заключается в упорядочении множества $\Z$.
		
		\begin{figure}[h]
			\hrule
			\begin{description}[nosep]
				\item[Дано:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item множество (возможно, бесконечное) объектов $\Z$ (обычно, но не обязательно, каждый объект представлен в виде вектора атрибутов)
					\item конечное множество попарных предпочтений $\bm{x}_i \succ \bm{x}_j, \: (\bm{x}_i, \bm{x}_j) \in \Z \times \Z$
				\end{itemize}
				\item[Найти:] \null\leavevmode
				\begin{itemize}[itemsep=0pt,leftmargin=2ex,label=\textbf{---}]
					\item функцию ранжирования $f(\cdot)$, которая принимает на вход множество объектов и возвращает перестановку (ранжирует) этого множества
				\end{itemize}
			\end{description} 
			\hrule
			\caption{\it Определение объектного ранжирования \cite[Рис.~3]{plbook:Introduction:2010}}
			\label{fig:object_ranking}
		\end{figure}
	
	\subsection{Подходы к реализации}
		В \cite{plbook:Introduction:2010} представлено четыре подхода к реализации алгоритмов ранжирования. 
		Первый вариант – выявить \emph{функцию полезности} (learning utility function) и построить полный порядок основываясь на значениях, полученных с помощью этой функции. Такой подход применим ко всем трем типам задач ранжирования. 
		Второй подход заключается в \emph{выявлении зависимостей} в попарных отношениях предпочтения (learning preference relations). Хотя часто подобный способ и создает более простую модель, в некоторых случаях может возникать нарушение транзитивности\cite[с.~10]{plbook:Introduction:2010}. 
		Третий подход называется \emph{обучение предпочтениям, основанное на модели} (model-based preference learning). Он используется в случаях, когда известны некоторые ограничения об отношениях предпочтения. 
		Последний подход, который выделяют авторы, называется \emph{локальное агрегирование предпочтений} (local aggregation of preferences). Основная идея данного метода заключается в поиске ближайших \enquote{соседей} для данного объекта.
		
		Очевидно, что описанные подходы не являются взаимоисключающими. Алгоритм выявления предпочтений \enquote{при прочих равных} является примером смешения подходов: с одной стороны, Алгоритм имеет дело с бинарными отношениями и подходит к типу ``выявления зависимостей''; с другой стороны, он работает с отношениями \enquote{при прочих равных}, что накладывает определенные ограничения на результирующую модель. Следовательно, Алгоритм так же может быть отнесен к обучению, ``основанному на модели''.
	
	
\section[Алгоритм выявления предпочтений \enquote{при прочих равных}]{\setstretch{0.8} Алгоритм выявления предпочтений \\ \enquote{при прочих равных}}

	Данный раздел основан на работе Объедкова \cite{Obiedkov:2013}, в которой представлен Алгоритм. Данный раздел состоит из двух пунктов: в первом представлен пример входных данных и описан ожидаемый результат работы Алгоритма, во втором представлено формальное определение Алгоритма.
	
	\subsection{Пример}
	\label{subsection:example}
		На рис. \ref{fig:pcxt} представлен пример контекста предпочтений. Объекты $c_1, \dotsc, c_5$ представляют машины, у каждой из которых есть свой набор признаков. Например, $c_2$ является белым внедорожником с темным интерьером. Диаграмма на правой стороне показывает отношение предпочтений какого-то пользователя: $c_1$ не хуже, чем $c_2$ и $c_3$; $c_5$ не хуже, чем $c_1$; $c_2$ и $c_3$ несравнимы; и так далее. 
		\begin{figure}
			\begin{center} 
				\cars \prefs
				\caption{\it Пример контекста предпочтений \cite[Рис.~1.1]{Obiedkov:2013}}
				\label{fig:pcxt}	
			\end{center} 
		\end{figure} 
		
		Задача алгоритма предсказать отношения предпочтения при добавлении нового объекта в контекст. В рассматриваемом примере в контекст может быть добавлен красный миниван с ярким интерьером, и Алгоритм должен выявить отношения предпочтения для добавленной машины, попарно сравнив её с $c_1, \dotsc, c_5$. 
	
	\subsection{Определения}
	\label{subsection:definitions}
		Представленный в данной работе алгоритм оперирует сущностями анализа формальных понятий\cite{Ganter:1999}, а так же понятиями, определенными в \cite{Obiedkov:2012:preferences,Obiedkov:2012:modeling}. В данном разделе представлены эти определения.
		
		
		\begin{definition}
			\emph{(Формальный) контекст} – это тройка $\context = (G, M, I)$, где $G$ называется множеством \emph{объектов}, $M$ называется множеством \emph{признаков}, и бинарное отношение ${I \subseteq G \times M}$ указывает на принадлежность признаков к каждому из объектов.
		\end{definition}
		
		Формаьлный контекст может быть визуализирован с помощью таблицы, такой как Рис. \ref{fig:pcxt}.
		
		Для множеств $A \subseteq G$ и $B \subseteq M$ следующим образом определены \emph{операторы Галуа} (derivation operators) $(\cdot)'$:
		\begin{subequations}
			\begin{gather}
			\label{eq:object_intent}
			A'=\{m \in M \mid \forall g \in A (g I m)\}  \\ 
			% 
			\label{eq:attribute_extent}
			B'=\{g \in G \mid \forall m \in B (g I m)\}
			\end{gather}
		\end{subequations}
		где $A'$ – это набор признаков, которые есть у всех объектов множества $A$, а $B'$  –- набор объектов, каждый из которых содержит все признаки множества $B$. Пусть $g \in G$ и $m \in M$, тогда множества $\{g\}'$ и $\{m\}'$ называются \emph{содержание объекта} (object intent) и \emph{объем признака} (attribute extent), соответственно. Иногда их обозначают как $g'$ и $m'$.
		
		\begin{definition}
			\emph{Контекст предпочтений} $\PP = (G, M, I, \leq)$ – это формальный контекст $(G, M, I)$ с рефлексивным и транзитивным отношением предпочтения $\leq$, определенным над $G$ (то есть, $\leq$ – предпорядок). Мы пишем $g < h$, если $g \leq h$ и $h \not\leq g$.
		\end{definition}
		
		Пример такого контекста представлен на Рис. \ref{fig:pcxt}.
		
		\begin{definition}
			Множество признаков $B \subseteq M$ \emph{предпочитается \enquote{при прочих равных}} множеству признаков $A \subseteq M$ по отношению ко множеству признаков $C \subseteq M$ в контексте предпочтений $\PP = (G, M, I, \leq)$ если 
			\begin{equation}
			\forall g \in A' \quad \forall h \in B' \quad (\{g\}' \cap C = \{h\}' \cap C \, \implies \, g \leq h).
			\end{equation}
			
			В таком случае мы говорим что предпочтение \emph{при прочих равных} $A \cp{C} B$ является \emph{валидным} или \emph{имеет место} в $\PP$ и обозначаем это как $\PP \models \ABC$.
		\end{definition}
	
	\subsection{Описание алгоритма}
		Чтобы найти предпочтение $\DEF$, поддерживаемое $\PP$, Алгоритм \ref{algo:prediction} итерируется по всем паром различных объектов $(g, h)$ контекста $\PP$ таких, что $g \leq h$. Для каждой такой пары он находит наиболее слабое предпочтение, которое объясняет и $g \leq h$, и предполагаемое предпочтение объекта, описываемого множеством признаков $B$, объекту, описываемого признаками $A$ ($A \leq B$). Левая часть этого предпочтения должна согласовываться и с $g'$, и с $A$; таким образом, $D := A \cap g'$. Похожим образом определяется и правая часть: $E := B \cap h'$. Признаки в условии \enquote{при прочих равных} должны быть согласованы как с общей частью между $g$ и $h$, так и с общей часть между $A$ и $B$. Таким образом, $F$ является множеством, которое содержит все признаки, по которым нет расхождений между $g'$ и $h'$ и между $A$ и $B$: каждый признак из $F$ принадлежит и $g'$, и $h'$, или ни одному из них, аналогично с $A$ и $B$. %<..>
		Если после итерации по всем парам $g \leq h$ не удалось найти предпочтение $\DEF$, объясняющее почему $B$ должно предпочитаться $A$, значит таких предпочтений, поддерживаемых $\PP$, нет, и алгоритм отвечает отрицательно.
	
		\begin{algorithm}
			\caption{\algname{Предсказание предпочтения}$(A, B, \PP)$ \cite[Алг.~1]{Obiedkov:2013}}
			\label{algo:prediction}
			\begin{algorithmic}[1]
				\REQUIRE Содержания объектов $A, B \subseteq M$ и контекст предпочтений $\PP = (G, M, I, \leq)$.
				\ENSURE \TRUE, если $\PP$ поддерживает $\DEF$ для некоторого $D \subseteq A, E \subseteq B,$ и $F \subseteq M$ таких, что $F \cap A = F \cap B$; \FALSE, иначе.
				\item[]
				\FORALL{$g \in G$}
				\STATE $D := A \cap g'$
				\FORALL{$h \in G \setminus \{g\}$ таких, что $g \leq h$}
				\STATE $E := B \cap h'$
				\STATE $F := (M \setminus (A \vartriangle B)) \cap (M \setminus (g' \vartriangle h'))$
				\IF{$\PP \models \DEF$}
				\RETURN \TRUE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \FALSE
			\end{algorithmic}
		\end{algorithm}
		\begin{algorithm}
			\caption{\algname{Проверить предпочтение}$(\DEF, \PP)$ \cite[Алг.~2]{Obiedkov:2013}}
			\label{algo:check}
			\begin{algorithmic}[1]
				\REQUIRE Предпочтение $\DEF$ над $M$ и контекст предпочтений $\PP = (G, M, I, \leq)$.%; assume that attribute extents, $m'$ for $m \in M$, are precomputed.
				\ENSURE \TRUE, если $\PP \models \DEF$; \FALSE, иначе.
				\item[]
				\STATE $X := \bigcap_{m \in D}m'$
				\STATE $Y := \bigcap_{m \in E}m'$
				\FORALL{$g \in X$}
				\FORALL{$h \in Y$}
				\IF {$g \not\leq h$ and $g' \cap {F} = h' \cap {F}$}
				\RETURN \FALSE
				\ENDIF
				\ENDFOR
				\ENDFOR
				\RETURN \TRUE
			\end{algorithmic}
		\end{algorithm}
		